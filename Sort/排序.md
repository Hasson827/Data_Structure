# 排序

## 排序的基本概念

排序(Sorting)是将数据的任意序列，重新排列成一个按照关键字有序(非递增有序或非递减有序)的序列的过程。

假设含有$n$个记录的序列为$\left\{R_{1},R_{2},\dots,R_{n}\right\}$，其相对应的关键字序列为$\left\{K_{1},K_{2},\dots,K_{n}\right\}$，这些关键字相互之间可以进行比较。若在它们之间存在着这样一个关系$K_{S1}\le K_{S2}\le\dots\le K_{Sn}$，则按此固有关系将$n$个记录的序列重新排列为$\left\{R_{S1},R_{S2},\dots,R_{Sn}\right\}$的操作称为排序。

若关键字$K_{i}$是记录$R_{i}\;(i=1,2,\dots,n)$的主关键字，则每个关键字可以唯一地标识一个记录，关键字各不相同。若$K_{i}$为次关键字，则在待排序的记录序列中可能有多个记录的关键字相同。在按照某种方法排序的过程中，若关键字相同的记录的相对位置不发生改变，则称所用的排序方法是稳定的；反之，称所用的排序方法是不稳定的。

在排序过程中，若待排序记录序列全部读入内存中处理，则称此类排序问题为内部排序；反之，若参加排序的记录数量较大，在排序过程中仅有部分记录在内存中，还要对外存中的记录进行访问，则称此类排序问题为外部排序。内部排序适用于记录个数不是很多的文件，而外部排序适用于记录个数很多的大文件，整个排序过程需要在内、外存之间多次交换数据才能得到排序的结果。

内部排序的方法通常可分为以下5类：

1. **插入排序**：将无序序列中的一个或几个记录“插入”到有序序列中，从而增加记录的有序序列的长度。
2. **交换排序**：通过“交换”无序序列中的相邻记录从而得到其中关键字最小或最大的记录，并将它增加到有序序列中，以增加记录的有序序列的长度。
3. **选择排序**：从记录的无序序列中“选择”关键字最小或最大的记录，并将它加到有序子序列中，以增加记录的有序序列的长度。
4. **归并排序**：通过“归并”两个或两个以上的有序序列，逐步增加有序序列的长度。
5. **分配排序**：通过对无序序列中的记录反复进行“分配”和“收集”操作，逐步使得无序序列变为有序序列。

一般来说，在排序过程中有两种基本操作：**比较关键字的大小**，以及**移动记录的位置**。前一种操作对大多数排序方法都是必要的，而后一种操作可通过改变记录的存储方式来避免。

评价排序算法效率的标准主要有两条：

1. 执行算法所需要的时间开销
2. 执行算法所需要的额外存储空间

## 插入排序

插入排序(Insertion Sorting)的基本思想是：首先将第一个记录看作一个有序序列，然后每次将下一个待排序的记录有序插入已排好序的有序序列中，使得有序序列逐步扩大，直到所有记录都加到有序序列中。主要有三种插入排序方法：直接插入排序、这班插入排序和希尔排序。

### 直接插入排序

直接插入排序(Straight Insertion Sort)是一种比较简单的插入排序方法。假设在排序过程中，记录序列为$R[0,\dots,n-1]$，首先将第一个记录$R[0]$看作一个有序子序列，然后依次将记录$R[i]\;(1\le i\le n-1)$插入有序子序列$R[0,\dots,i-1]$中，使记录的有序子序列从$R[0,\dots,i-1]$变为$R[0,\dots,i]$。

```c++
template <class Type>
void straightInsertSort(Type R[], int size){
    int pos, j; // pos为待插入位置记录
    Type temp;
    for(pos = 1, pos < size; pos++){
        temp = R[pos]; // 记录待插入的元素
        for(j = pos - 1; j >= 0 && R[j] > temp; j--) // 从后往前查找插入位置
            R[j + 1] = R[j]; // 将R[j]后移
        R[j + 1] = temp; // 插入R[pos]到正确位置
    }
}
```

直接插入排序算法简单，容易实现，是一种稳定的排序方法。当待排序记录数量$n$很小且局部有序时较为适用。当$n$很大时，其效率不高。它的基本操作有两种：比较关键字和移动记录。

最好的情况是：初始序列为有序，关键字总比较次数为最小值$(n-1)$，即$\sum_{i=2}^{n}{1}$，无需后移记录，但在一趟排序开始时要将待排序记录放进临时变量中，在一趟排序结束时再将待排序记录放到合适位置，需要移动记录$2(n-1)$次。

最坏的情况是，初始序列为逆序，关键字总比较次数为最大值$\sum_{i=2}^{n}{i}=\frac{(n+2)(n-1)}{2}$，记录移动次数为最大值$\sum_{i=2}^{n}{i-1+2}=\frac{(n+4)(n-1)}{2}$。

由此可见，直接插入排序算法最好情况的时间复杂度为$O(n)$，最坏情况时间复杂度和平均时间复杂度为$O(n^{2})$。在直接插入排序中，只需一个记录大小的辅助空间用于存放待插入的记录，因此空间复杂度为$O(1)$。

### 折半插入排序

对直接插入排序算法进行改进，可从减少比较和移动次数这两方面着手。当前面有$i-1$个有序记录序列时，要插入第$i$个序列，可利用折半查找方式确定插入位置，以减少比较次数。这种排序方法称为折半排序插入(Binary Insertion Sort)，其算法如下：

```c++
template <class Type>
void binaryInsertSort(Type R[], int size){
    int pos, j, low, high, mid;
    Type temp;
    for(pos = 1; pos < size; pos++){
        temp = R[pos];
        low = 0; high = pos - 1;
        while(low <= high){
            mid = (low + high) / 2; // 查找中间位置
            if(R[mid] > temp) high = mid - 1; // 在左半边继续查找
            else low = mid + 1; // 在右半边继续查找
        }
        for(j = pos - 1; j >= low; j--)
            R[j + 1] = R[j]; // 将R[j]后移
        R[low] = temp; // 插入R[pos]到正确位置
    }
}
```

折半插入排序比直接插入排序明显地减少了关键字间的比较次数，但记录移动的次数不变，故其时间复杂度仍然为$O(n^{2})$。

### 希尔排序

## 交换排序

交换排序(Exchange Sort)的基本思想是：对待排序记录序列中元素间关键字比较，若发现记录逆序，则交换。主要有两种交换排序方法：冒泡排序和快速排序。

### 冒泡排序

冒泡排序(Bubble Sort)是一种比较简单的交换排序方法。它的基本思想是：对所有相邻记录的关键字进行比较，若不满足排序要求(即逆序)，则将其交换，直到所有记录排好序为止。对于由$n$个记录组成的记录序列，冒泡排序的步骤如下：

1. 将整个待排序的记录序列划分成有序区和无序区，初始状态有序区为空，无序区包括所有待排序的记录。
2. 每一趟冒泡排序，对无序区从头到尾比较相邻记录的关键字，若逆序，则将关键字小的记录换到前面，关键字大的记录换到后面。一趟排序后，无序区中关键字最大的记录进入有序区。
3. 重复执行步骤2， 若在某一趟排序中没有发生交换操作，则说明待排序记录已经全部有序，排序提前结束；否则，最多需要经过$n-1$趟冒泡排序，才能将这$n$个记录重新按照关键字排好序。

冒泡排序算法如下：

```c++
template <class Type>
void bubbleSort(Type R[], int size){
    int i, j;
    bool flag = true; // 标志变量，表示是否发生交换
    for(i = 1; i < size && flag; i++){
        flag = false; // 每次开始时假设没有交换
        for(j = 0; j < size - i; j++){
            if(R[j+1] < R[j]){
                swap(R[j], R[j+1]);
                flag = true; // 如果发生交换，设置标志为true
            }
        }
    }
}
```

冒泡排序是一种稳定的排序方法，关键字的比较次数和记录的交换次数与记录的初始顺序有关。最好的情况是，初始序列为有序，比较次数为$n-1$，交换次数为$0$；最坏的情况是，初始序列为逆序，比较次数和交换次数均为$\sum_{i=1}^{n-1}{(n-i)}=\frac{n(n-1)}{2}$，记录的移动次数为$\frac{3n(n-1)}{2}$，因此，最好情况的时间复杂度为$O(n)$，最坏情况时间复杂度和平均时间复杂度为$O(n^{2})$。在冒泡排序过程中，只需要一个记录大小的辅助空间用于交换，因此空间复杂度为$O(1)$。

### 快速排序

## 选择排序

### 直接选择排序

### 堆排序

### 锦标赛排序

## 归并排序

## 基数排序

## 各种内部排序方法的比较

## 外部排序

### 置换选择排序

### 多路并归排序